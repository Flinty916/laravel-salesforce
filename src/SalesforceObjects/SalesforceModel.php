<?php

namespace Flinty916\LaravelSalesforce\SalesforceObjects;

use Carbon\Carbon;
use Flinty916\LaravelSalesforce\Service\SalesforceClient;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Log;
use stdClass;

abstract class SalesforceModel
{

    protected static string $object = "";
    public ?string $Id = null;

    /** Bag for SFDC field values (raw or casted-in) */
    protected array $attributes = [];

    /**
     * Per-class casts generated by your console command.
     * Supported: string|int|float|bool|date|datetime
     * e.g. ['CreatedDate' => 'datetime', 'OCT__c' => 'bool']
     * @var array<string,string>
     */
    protected static array $casts = [];

    protected static function client(): SalesforceClient
    {
        return app(SalesforceClient::class);
    }

    public static function query(): SalesforceQueryBuilder
    {
        return new SalesforceQueryBuilder(static::$object);
    }

    public static function fields(array $fields): SalesforceQueryBuilder
    {
        return static::query()->fields($fields);
    }

    public static function where(...$args): SalesforceQueryBuilder
    {
        return static::query()->where(...$args);
    }

    public static function orWhere(...$args): SalesforceQueryBuilder
    {
        return static::query()->orWhere(...$args);
    }

    public static function orderBy(string $field, string $direction = 'asc'): SalesforceQueryBuilder
    {
        return static::query()->orderBy($field, $direction);
    }

    public static function limit(int $limit): SalesforceQueryBuilder
    {
        return static::query()->limit($limit);
    }

    public static function get(): SalesforceQueryBuilder
    {
        return static::query()->get();
    }

    public static function find(string $id): ?static
    {
        $record = static::query()
            ->fields(['FIELDS(ALL)'])
            ->where('Id', '=', $id)
            ->limit(1)
            ->first();

        if (!$record) {
            return null;
        }

        $model = new static();
        foreach ($record as $key => $value) {
            $model->{$key} = $value;
        }

        return $model;
    }

    public static function records(): Collection
    {
        return static::query()->records();
    }

    public static function create(array|stdClass $data): ?static
    {
        $response = (self::client()->post('/services/data/v' . config('salesforce.api_version') . '/sobjects/' . static::$object, $data))->id;
        $model = new static();
        $model->Id = $response;
        return $model;
    }

    public function update(array|stdClass $data): void
    {
        $this->client()->put('/services/data/v' . config('salesforce.api_version') . '/sobjects/' . static::$object . '/' . $this->Id, $data);
    }

    public function delete(): void
    {
        $this->client()->delete('/services/data/v' . config('salesforce.api_version') . '/sobjects/' . static::$object . '/' . $this->Id);
    }

    // Properties:

    public static function fromArray(array $attributes): static
    {
        return new static($attributes);
    }

    /**
     * Accepts an SFDC "record" (array|object) and returns a hydrated model.
     */
    public static function hydrateRecord(array|object $record): static
    {
        $arr = is_array($record) ? $record : (array) $record;

        // Salesforce often includes a meta 'attributes' key we don't want to treat as a field.
        if (array_key_exists('attributes', $arr) && is_array($arr['attributes'])) {
            unset($arr['attributes']);
        }

        return new static($arr);
    }

    /**
     * Bulk fill with cast-in.
     */
    public function fill(array $attributes): static
    {
        foreach ($attributes as $key => $value) {
            $this->__set($key, $value);
        }
        return $this;
    }

    public function __get(string $key)
    {
        if (!array_key_exists($key, $this->attributes)) {
            return null;
        }
        return $this->castOut($key, $this->attributes[$key]);
    }

    public function __set(string $key, $value): void
    {
        // Prevent clobbering internal properties
        if (property_exists($this, $key)) {
            throw new \LogicException("Cannot set protected property '{$key}' on " . static::class);
        }

        $this->attributes[$key] = $this->castIn($key, $value);
    }

    public function __isset(string $key): bool
    {
        return isset($this->attributes[$key]);
    }

    public function __unset(string $key): void
    {
        unset($this->attributes[$key]);
    }

    /**
     * Returns a shallow copy of the raw (internal) attribute bag.
     */
    public function rawAttributes(): array
    {
        return $this->attributes;
    }

    /**
     * Array form with cast-out applied (good for JSON responses).
     */
    public function toArray(): array
    {
        $out = [];
        foreach ($this->attributes as $k => $v) {
            $out[$k] = $this->castOut($k, $v);
        }
        return $out;
    }

    public function jsonSerialize(): array
    {
        return $this->toArray();
    }

    protected function castIn(string $key, $value)
    {
        if ($value === null) return null;

        $rule = static::$casts[$key] ?? null;

        return match ($rule) {
            'int'       => (int) $value,
            'float'     => (float) $value,
            'bool'      => (bool) $value,
            'string'    => (string) $value,
            'date', 'datetime' => $value instanceof Carbon ? $value : Carbon::parse($value),
            default     => $value,
        };
    }

    protected function castOut(string $key, $value)
    {
        if ($value === null) return null;

        $rule = static::$casts[$key] ?? null;

        return match ($rule) {
            'date', 'datetime' => ($value instanceof Carbon) ? $value : Carbon::parse($value),
            default            => $value,
        };
    }
}
